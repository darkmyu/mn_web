/**
 * Generated by orval v7.17.0 ðŸº
 * Do not edit manually.
 * OpenAPI spec version: 1.0.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from '@tanstack/react-query';

import type { AuthCheckDuplicateUsernameRequest, AuthInfoResponse, AuthRegisterRequest } from './index.schemas';

export type authControllerInfoResponse200 = {
  data: AuthInfoResponse;
  status: 200;
};

export type authControllerInfoResponseSuccess = authControllerInfoResponse200 & {
  headers: Headers;
};
export const getAuthControllerInfoUrl = () => {
  return `http://localhost:4000/api/v1/auth/info`;
};

export const authControllerInfo = async (options?: RequestInit): Promise<authControllerInfoResponseSuccess> => {
  const res = await fetch(getAuthControllerInfoUrl(), {
    credentials: 'include',
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  if (!res.ok) {
    const err: globalThis.Error & { info?: any; status?: number } = new globalThis.Error();
    const data = body ? JSON.parse(body) : {};
    err.info = data;
    err.status = res.status;
    throw err;
  }
  const data: authControllerInfoResponseSuccess['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as authControllerInfoResponseSuccess;
};

export const getAuthControllerInfoInfiniteQueryKey = () => {
  return ['infinite', `http://localhost:4000/api/v1/auth/info`] as const;
};

export const getAuthControllerInfoQueryKey = () => {
  return [`http://localhost:4000/api/v1/auth/info`] as const;
};

export const getAuthControllerInfoInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerInfo>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerInfoInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerInfo>>> = ({ signal }) =>
    authControllerInfo({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authControllerInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthControllerInfoInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerInfo>>>;
export type AuthControllerInfoInfiniteQueryError = unknown;

export function useAuthControllerInfoInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerInfo>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerInfo>>,
          TError,
          Awaited<ReturnType<typeof authControllerInfo>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerInfoInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerInfo>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerInfo>>,
          TError,
          Awaited<ReturnType<typeof authControllerInfo>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerInfoInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerInfo>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAuthControllerInfoInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerInfo>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerInfoInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchAuthControllerInfoInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof authControllerInfo>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getAuthControllerInfoInfiniteQueryOptions(options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getAuthControllerInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof authControllerInfo>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerInfoQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerInfo>>> = ({ signal }) =>
    authControllerInfo({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authControllerInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthControllerInfoQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerInfo>>>;
export type AuthControllerInfoQueryError = unknown;

export function useAuthControllerInfo<TData = Awaited<ReturnType<typeof authControllerInfo>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerInfo>>,
          TError,
          Awaited<ReturnType<typeof authControllerInfo>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerInfo<TData = Awaited<ReturnType<typeof authControllerInfo>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerInfo>>,
          TError,
          Awaited<ReturnType<typeof authControllerInfo>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerInfo<TData = Awaited<ReturnType<typeof authControllerInfo>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAuthControllerInfo<TData = Awaited<ReturnType<typeof authControllerInfo>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerInfoQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchAuthControllerInfoQuery = async <
  TData = Awaited<ReturnType<typeof authControllerInfo>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getAuthControllerInfoQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getAuthControllerInfoSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof authControllerInfo>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerInfoQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerInfo>>> = ({ signal }) =>
    authControllerInfo({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof authControllerInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthControllerInfoSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerInfo>>>;
export type AuthControllerInfoSuspenseQueryError = unknown;

export function useAuthControllerInfoSuspense<TData = Awaited<ReturnType<typeof authControllerInfo>>, TError = unknown>(
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerInfoSuspense<TData = Awaited<ReturnType<typeof authControllerInfo>>, TError = unknown>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerInfoSuspense<TData = Awaited<ReturnType<typeof authControllerInfo>>, TError = unknown>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAuthControllerInfoSuspense<TData = Awaited<ReturnType<typeof authControllerInfo>>, TError = unknown>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerInfoSuspenseQueryOptions(options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthControllerInfoSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerInfo>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerInfoInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerInfo>>> = ({ signal }) =>
    authControllerInfo({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authControllerInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthControllerInfoSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerInfo>>>;
export type AuthControllerInfoSuspenseInfiniteQueryError = unknown;

export function useAuthControllerInfoSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerInfo>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerInfoSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerInfo>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerInfoSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerInfo>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAuthControllerInfoSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerInfo>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerInfo>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerInfoSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(queryOptions, queryClient) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type authControllerGoogleResponse200 = {
  data: void;
  status: 200;
};

export type authControllerGoogleResponseSuccess = authControllerGoogleResponse200 & {
  headers: Headers;
};
export const getAuthControllerGoogleUrl = () => {
  return `http://localhost:4000/api/v1/auth/google`;
};

export const authControllerGoogle = async (options?: RequestInit): Promise<authControllerGoogleResponseSuccess> => {
  const res = await fetch(getAuthControllerGoogleUrl(), {
    credentials: 'include',
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  if (!res.ok) {
    const err: globalThis.Error & { info?: any; status?: number } = new globalThis.Error();
    const data = body ? JSON.parse(body) : {};
    err.info = data;
    err.status = res.status;
    throw err;
  }
  const data: authControllerGoogleResponseSuccess['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as authControllerGoogleResponseSuccess;
};

export const getAuthControllerGoogleInfiniteQueryKey = () => {
  return ['infinite', `http://localhost:4000/api/v1/auth/google`] as const;
};

export const getAuthControllerGoogleQueryKey = () => {
  return [`http://localhost:4000/api/v1/auth/google`] as const;
};

export const getAuthControllerGoogleInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGoogle>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerGoogleInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGoogle>>> = ({ signal }) =>
    authControllerGoogle({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authControllerGoogle>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthControllerGoogleInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGoogle>>>;
export type AuthControllerGoogleInfiniteQueryError = unknown;

export function useAuthControllerGoogleInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGoogle>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGoogle>>,
          TError,
          Awaited<ReturnType<typeof authControllerGoogle>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerGoogleInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGoogle>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGoogle>>,
          TError,
          Awaited<ReturnType<typeof authControllerGoogle>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerGoogleInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGoogle>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAuthControllerGoogleInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGoogle>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerGoogleInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchAuthControllerGoogleInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof authControllerGoogle>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getAuthControllerGoogleInfiniteQueryOptions(options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getAuthControllerGoogleQueryOptions = <
  TData = Awaited<ReturnType<typeof authControllerGoogle>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerGoogleQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGoogle>>> = ({ signal }) =>
    authControllerGoogle({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authControllerGoogle>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthControllerGoogleQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGoogle>>>;
export type AuthControllerGoogleQueryError = unknown;

export function useAuthControllerGoogle<TData = Awaited<ReturnType<typeof authControllerGoogle>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGoogle>>,
          TError,
          Awaited<ReturnType<typeof authControllerGoogle>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerGoogle<TData = Awaited<ReturnType<typeof authControllerGoogle>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGoogle>>,
          TError,
          Awaited<ReturnType<typeof authControllerGoogle>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerGoogle<TData = Awaited<ReturnType<typeof authControllerGoogle>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAuthControllerGoogle<TData = Awaited<ReturnType<typeof authControllerGoogle>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerGoogleQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchAuthControllerGoogleQuery = async <
  TData = Awaited<ReturnType<typeof authControllerGoogle>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getAuthControllerGoogleQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getAuthControllerGoogleSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof authControllerGoogle>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerGoogleQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGoogle>>> = ({ signal }) =>
    authControllerGoogle({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof authControllerGoogle>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthControllerGoogleSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGoogle>>>;
export type AuthControllerGoogleSuspenseQueryError = unknown;

export function useAuthControllerGoogleSuspense<
  TData = Awaited<ReturnType<typeof authControllerGoogle>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerGoogleSuspense<
  TData = Awaited<ReturnType<typeof authControllerGoogle>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerGoogleSuspense<
  TData = Awaited<ReturnType<typeof authControllerGoogle>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAuthControllerGoogleSuspense<
  TData = Awaited<ReturnType<typeof authControllerGoogle>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerGoogleSuspenseQueryOptions(options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthControllerGoogleSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGoogle>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerGoogleInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGoogle>>> = ({ signal }) =>
    authControllerGoogle({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authControllerGoogle>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthControllerGoogleSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authControllerGoogle>>
>;
export type AuthControllerGoogleSuspenseInfiniteQueryError = unknown;

export function useAuthControllerGoogleSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGoogle>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerGoogleSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGoogle>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerGoogleSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGoogle>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAuthControllerGoogleSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGoogle>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGoogle>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerGoogleSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(queryOptions, queryClient) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type authControllerNaverResponse200 = {
  data: void;
  status: 200;
};

export type authControllerNaverResponseSuccess = authControllerNaverResponse200 & {
  headers: Headers;
};
export const getAuthControllerNaverUrl = () => {
  return `http://localhost:4000/api/v1/auth/naver`;
};

export const authControllerNaver = async (options?: RequestInit): Promise<authControllerNaverResponseSuccess> => {
  const res = await fetch(getAuthControllerNaverUrl(), {
    credentials: 'include',
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  if (!res.ok) {
    const err: globalThis.Error & { info?: any; status?: number } = new globalThis.Error();
    const data = body ? JSON.parse(body) : {};
    err.info = data;
    err.status = res.status;
    throw err;
  }
  const data: authControllerNaverResponseSuccess['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as authControllerNaverResponseSuccess;
};

export const getAuthControllerNaverInfiniteQueryKey = () => {
  return ['infinite', `http://localhost:4000/api/v1/auth/naver`] as const;
};

export const getAuthControllerNaverQueryKey = () => {
  return [`http://localhost:4000/api/v1/auth/naver`] as const;
};

export const getAuthControllerNaverInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerNaver>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerNaverInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerNaver>>> = ({ signal }) =>
    authControllerNaver({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authControllerNaver>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthControllerNaverInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerNaver>>>;
export type AuthControllerNaverInfiniteQueryError = unknown;

export function useAuthControllerNaverInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerNaver>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerNaver>>,
          TError,
          Awaited<ReturnType<typeof authControllerNaver>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerNaverInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerNaver>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerNaver>>,
          TError,
          Awaited<ReturnType<typeof authControllerNaver>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerNaverInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerNaver>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAuthControllerNaverInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerNaver>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerNaverInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchAuthControllerNaverInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof authControllerNaver>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getAuthControllerNaverInfiniteQueryOptions(options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getAuthControllerNaverQueryOptions = <
  TData = Awaited<ReturnType<typeof authControllerNaver>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerNaverQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerNaver>>> = ({ signal }) =>
    authControllerNaver({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authControllerNaver>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthControllerNaverQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerNaver>>>;
export type AuthControllerNaverQueryError = unknown;

export function useAuthControllerNaver<TData = Awaited<ReturnType<typeof authControllerNaver>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerNaver>>,
          TError,
          Awaited<ReturnType<typeof authControllerNaver>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerNaver<TData = Awaited<ReturnType<typeof authControllerNaver>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerNaver>>,
          TError,
          Awaited<ReturnType<typeof authControllerNaver>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerNaver<TData = Awaited<ReturnType<typeof authControllerNaver>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAuthControllerNaver<TData = Awaited<ReturnType<typeof authControllerNaver>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerNaverQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchAuthControllerNaverQuery = async <
  TData = Awaited<ReturnType<typeof authControllerNaver>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getAuthControllerNaverQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getAuthControllerNaverSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof authControllerNaver>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerNaverQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerNaver>>> = ({ signal }) =>
    authControllerNaver({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof authControllerNaver>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthControllerNaverSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerNaver>>>;
export type AuthControllerNaverSuspenseQueryError = unknown;

export function useAuthControllerNaverSuspense<
  TData = Awaited<ReturnType<typeof authControllerNaver>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerNaverSuspense<
  TData = Awaited<ReturnType<typeof authControllerNaver>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerNaverSuspense<
  TData = Awaited<ReturnType<typeof authControllerNaver>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAuthControllerNaverSuspense<
  TData = Awaited<ReturnType<typeof authControllerNaver>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerNaverSuspenseQueryOptions(options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthControllerNaverSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerNaver>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerNaverInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerNaver>>> = ({ signal }) =>
    authControllerNaver({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authControllerNaver>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthControllerNaverSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authControllerNaver>>
>;
export type AuthControllerNaverSuspenseInfiniteQueryError = unknown;

export function useAuthControllerNaverSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerNaver>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerNaverSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerNaver>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerNaverSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerNaver>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAuthControllerNaverSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerNaver>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerNaver>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerNaverSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(queryOptions, queryClient) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type authControllerKakaoResponse200 = {
  data: void;
  status: 200;
};

export type authControllerKakaoResponseSuccess = authControllerKakaoResponse200 & {
  headers: Headers;
};
export const getAuthControllerKakaoUrl = () => {
  return `http://localhost:4000/api/v1/auth/kakao`;
};

export const authControllerKakao = async (options?: RequestInit): Promise<authControllerKakaoResponseSuccess> => {
  const res = await fetch(getAuthControllerKakaoUrl(), {
    credentials: 'include',
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  if (!res.ok) {
    const err: globalThis.Error & { info?: any; status?: number } = new globalThis.Error();
    const data = body ? JSON.parse(body) : {};
    err.info = data;
    err.status = res.status;
    throw err;
  }
  const data: authControllerKakaoResponseSuccess['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as authControllerKakaoResponseSuccess;
};

export const getAuthControllerKakaoInfiniteQueryKey = () => {
  return ['infinite', `http://localhost:4000/api/v1/auth/kakao`] as const;
};

export const getAuthControllerKakaoQueryKey = () => {
  return [`http://localhost:4000/api/v1/auth/kakao`] as const;
};

export const getAuthControllerKakaoInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerKakao>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerKakaoInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerKakao>>> = ({ signal }) =>
    authControllerKakao({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authControllerKakao>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthControllerKakaoInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerKakao>>>;
export type AuthControllerKakaoInfiniteQueryError = unknown;

export function useAuthControllerKakaoInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerKakao>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerKakao>>,
          TError,
          Awaited<ReturnType<typeof authControllerKakao>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerKakaoInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerKakao>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerKakao>>,
          TError,
          Awaited<ReturnType<typeof authControllerKakao>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerKakaoInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerKakao>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAuthControllerKakaoInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerKakao>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerKakaoInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchAuthControllerKakaoInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof authControllerKakao>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getAuthControllerKakaoInfiniteQueryOptions(options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getAuthControllerKakaoQueryOptions = <
  TData = Awaited<ReturnType<typeof authControllerKakao>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerKakaoQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerKakao>>> = ({ signal }) =>
    authControllerKakao({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authControllerKakao>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthControllerKakaoQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerKakao>>>;
export type AuthControllerKakaoQueryError = unknown;

export function useAuthControllerKakao<TData = Awaited<ReturnType<typeof authControllerKakao>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerKakao>>,
          TError,
          Awaited<ReturnType<typeof authControllerKakao>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerKakao<TData = Awaited<ReturnType<typeof authControllerKakao>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerKakao>>,
          TError,
          Awaited<ReturnType<typeof authControllerKakao>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerKakao<TData = Awaited<ReturnType<typeof authControllerKakao>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAuthControllerKakao<TData = Awaited<ReturnType<typeof authControllerKakao>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerKakaoQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchAuthControllerKakaoQuery = async <
  TData = Awaited<ReturnType<typeof authControllerKakao>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getAuthControllerKakaoQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getAuthControllerKakaoSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof authControllerKakao>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerKakaoQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerKakao>>> = ({ signal }) =>
    authControllerKakao({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof authControllerKakao>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthControllerKakaoSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerKakao>>>;
export type AuthControllerKakaoSuspenseQueryError = unknown;

export function useAuthControllerKakaoSuspense<
  TData = Awaited<ReturnType<typeof authControllerKakao>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerKakaoSuspense<
  TData = Awaited<ReturnType<typeof authControllerKakao>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerKakaoSuspense<
  TData = Awaited<ReturnType<typeof authControllerKakao>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAuthControllerKakaoSuspense<
  TData = Awaited<ReturnType<typeof authControllerKakao>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerKakaoSuspenseQueryOptions(options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthControllerKakaoSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerKakao>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerKakaoInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerKakao>>> = ({ signal }) =>
    authControllerKakao({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authControllerKakao>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthControllerKakaoSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authControllerKakao>>
>;
export type AuthControllerKakaoSuspenseInfiniteQueryError = unknown;

export function useAuthControllerKakaoSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerKakao>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerKakaoSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerKakao>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAuthControllerKakaoSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerKakao>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAuthControllerKakaoSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerKakao>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerKakao>>, TError, TData>>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerKakaoSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(queryOptions, queryClient) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type authControllerRegisterResponse200 = {
  data: AuthInfoResponse;
  status: 200;
};

export type authControllerRegisterResponseSuccess = authControllerRegisterResponse200 & {
  headers: Headers;
};
export const getAuthControllerRegisterUrl = () => {
  return `http://localhost:4000/api/v1/auth/register`;
};

export const authControllerRegister = async (
  authRegisterRequest: AuthRegisterRequest,
  options?: RequestInit,
): Promise<authControllerRegisterResponseSuccess> => {
  const res = await fetch(getAuthControllerRegisterUrl(), {
    credentials: 'include',
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(authRegisterRequest),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  if (!res.ok) {
    const err: globalThis.Error & { info?: any; status?: number } = new globalThis.Error();
    const data = body ? JSON.parse(body) : {};
    err.info = data;
    err.status = res.status;
    throw err;
  }
  const data: authControllerRegisterResponseSuccess['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as authControllerRegisterResponseSuccess;
};

export const getAuthControllerRegisterMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerRegister>>,
    TError,
    { data: AuthRegisterRequest },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerRegister>>,
  TError,
  { data: AuthRegisterRequest },
  TContext
> => {
  const mutationKey = ['authControllerRegister'];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerRegister>>,
    { data: AuthRegisterRequest }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerRegister(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerRegister>>>;
export type AuthControllerRegisterMutationBody = AuthRegisterRequest;
export type AuthControllerRegisterMutationError = unknown;

export const useAuthControllerRegister = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authControllerRegister>>,
      TError,
      { data: AuthRegisterRequest },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authControllerRegister>>,
  TError,
  { data: AuthRegisterRequest },
  TContext
> => {
  const mutationOptions = getAuthControllerRegisterMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export type authControllerCheckDuplicateUsernameResponse200 = {
  data: void;
  status: 200;
};

export type authControllerCheckDuplicateUsernameResponseSuccess = authControllerCheckDuplicateUsernameResponse200 & {
  headers: Headers;
};
export const getAuthControllerCheckDuplicateUsernameUrl = () => {
  return `http://localhost:4000/api/v1/auth/check-duplicate-username`;
};

export const authControllerCheckDuplicateUsername = async (
  authCheckDuplicateUsernameRequest: AuthCheckDuplicateUsernameRequest,
  options?: RequestInit,
): Promise<authControllerCheckDuplicateUsernameResponseSuccess> => {
  const res = await fetch(getAuthControllerCheckDuplicateUsernameUrl(), {
    credentials: 'include',
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(authCheckDuplicateUsernameRequest),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  if (!res.ok) {
    const err: globalThis.Error & { info?: any; status?: number } = new globalThis.Error();
    const data = body ? JSON.parse(body) : {};
    err.info = data;
    err.status = res.status;
    throw err;
  }
  const data: authControllerCheckDuplicateUsernameResponseSuccess['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as authControllerCheckDuplicateUsernameResponseSuccess;
};

export const getAuthControllerCheckDuplicateUsernameMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerCheckDuplicateUsername>>,
    TError,
    { data: AuthCheckDuplicateUsernameRequest },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerCheckDuplicateUsername>>,
  TError,
  { data: AuthCheckDuplicateUsernameRequest },
  TContext
> => {
  const mutationKey = ['authControllerCheckDuplicateUsername'];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerCheckDuplicateUsername>>,
    { data: AuthCheckDuplicateUsernameRequest }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerCheckDuplicateUsername(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerCheckDuplicateUsernameMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerCheckDuplicateUsername>>
>;
export type AuthControllerCheckDuplicateUsernameMutationBody = AuthCheckDuplicateUsernameRequest;
export type AuthControllerCheckDuplicateUsernameMutationError = unknown;

export const useAuthControllerCheckDuplicateUsername = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authControllerCheckDuplicateUsername>>,
      TError,
      { data: AuthCheckDuplicateUsernameRequest },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authControllerCheckDuplicateUsername>>,
  TError,
  { data: AuthCheckDuplicateUsernameRequest },
  TContext
> => {
  const mutationOptions = getAuthControllerCheckDuplicateUsernameMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export type authControllerLogoutResponse201 = {
  data: void;
  status: 201;
};

export type authControllerLogoutResponseSuccess = authControllerLogoutResponse201 & {
  headers: Headers;
};
export const getAuthControllerLogoutUrl = () => {
  return `http://localhost:4000/api/v1/auth/logout`;
};

export const authControllerLogout = async (options?: RequestInit): Promise<authControllerLogoutResponseSuccess> => {
  const res = await fetch(getAuthControllerLogoutUrl(), {
    credentials: 'include',
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  if (!res.ok) {
    const err: globalThis.Error & { info?: any; status?: number } = new globalThis.Error();
    const data = body ? JSON.parse(body) : {};
    err.info = data;
    err.status = res.status;
    throw err;
  }
  const data: authControllerLogoutResponseSuccess['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as authControllerLogoutResponseSuccess;
};

export const getAuthControllerLogoutMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError, void, TContext>;
  fetch?: RequestInit;
}): UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError, void, TContext> => {
  const mutationKey = ['authControllerLogout'];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLogout>>, void> = () => {
    return authControllerLogout(fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogout>>>;

export type AuthControllerLogoutMutationError = unknown;

export const useAuthControllerLogout = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError, void, TContext>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof authControllerLogout>>, TError, void, TContext> => {
  const mutationOptions = getAuthControllerLogoutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
